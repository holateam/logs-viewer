# Ppl

## listener.js
При стартовом запуске *listener.js* считывает с БД `host` и `port` всех зарегистрированных клиентов и поднимает для каждого tcp сервер, на который приходят логи с утилиты remote_syslog2, которая установлена на сервере клиента. Так же *listener* устанавливает соединение с основным сервером по web-socket. Изменения файла с логами приходят на tcp сервер, где логи парсятся в JSON и выполняется запись в БД:
```
{
    "id" : "1234567890",                  // автоинкрементный индекс
    "created_at" : "2016-10-06 23:59:59", // время фиксации ивента
    "user_id" : "<host>:<port>",          // выданные при регистрации пользователя
    "sender_ip" : "127.0.0.1",            // с какого ip пришел ивент
    "file_name" : "somefile.log",         // какой отслеживаемый файл изменился
    "message" : "some logs..."            // собственно, сами изменения
}
```
а так же генерируется событие `new_logs`, которое отправляет логи на основной сервер.

## server <=> listener
Между основным сервером и *listener'ом* устанавливается соединение по web-socket. 

##### Событие `new_logs`
Сервер слушает событие `new_logs`, на которое с *listener'а* в режиме реального времени приходит JSON объект с информацией о новом логе: 
```
{
    "created_at" : "2016-10-06 23:59:59", // время фиксации ивента
    "user_id" : "<host>:<port>",          // выданные при регистрации пользователя
    "sender_ip" : "127.0.0.1",            // с какого ip пришел ивент
    "file_name" : "somefile.log",         // какой отслеживаемый файл изменился
    "message" : "some logs..."            // собственно, сами изменения
}
```
Сервер проверяет состояние клиента и если юзер смотрит логи в реальном времени - пересылает ему JSON объект с новыми логами.

##### Событие `start_new_server`
После регистрации нового пользователя сервер генерирует новое событие `start_new_server` и на *listener* отправляется `host`, `port` и `timeZone` нового клиента для поднятия нового tcp сервера: 
```
{
    "timeZone" : "+02.00",
    "host" : "127.0.0.1",
    "port" : 3000
}
```

## server <=> client
После авторизации пользователя (toDo) в БД сохраняется данные о пользователе: 
```
{
    "email" : "user@gmail.com",
    "password" : "anypass",
    "timeZone" : "+02.00",
    "host" : "127.0.0.1",
    "port" : 3000
}
```
со стороны клиента генерируется web-socket событие `connection`. В самом сокете создаются две переменные `minId` и `maxId`равные нулю, а также `isPaused` равная *false*.

##### Событие `send_user_data`
Данное событие должно быть сгенерировано клиентом после установки соединения по web-socket для сообщения серверу своих идентификационных данных, передачи настроек и получения первой порции данных. Клиент передает на сервер объект JSON:
```
{
    "user_id" : "<host>:<port>",
    "watched_ip" : "127.0.0.1",
    "logs_portion" : "100"
}
```
Значение `user_id` сразу вносится в map `connectedUsers`, который хранит пары `{"user_id" : "socket"}`, остальные параметры прописываются в соответствующие переменные внутри сокета.
Сервер делает запрос в БД для получения первой порции данных (последние `logs_portion` записей) и возвращает их клиенту путем генерирования события `send_logs`.

##### Событие `get_logs`
Генерируется клиентом для запроса каждой следующей порции данных. Приняв это событие сервер делает обращение к базе данных с учетом значений `minId` и `maxId`. В ответ на данное событие сервер генерирует событие `send_logs`.

##### Событие `send_logs`
Генерируется сервером в ответ на событие `get_logs` и передает массив объектов JSON:
```
{
    "events": [
        {
            "created_at" : "2016-10-06 23:59:59",
            "sender_ip" : "127.0.0.1",
            "file_name" : "somefile.log",
            "message" : "some logs...",
        },
        ...
    ]
    "isOldestEventReached" : "false"
}
```
Дополнительное поле `isOldestEventReached` указывает достингута ли самая старая запись.

##### Событие `live_update_logs`
Событие `live_update_logs` генерируется сервером после получения от *listener'а* нового лога и проверки наличия данного юзера в слушетелях логов в реальном времени - `connectedUsers` если флаг `isPaused` равнен *false* и отдается объект JSON:
```
{
    event: {
        "created_at" : "2016-10-06 23:59:59",
        "sender_ip" : "127.0.0.1",
        "file_name" : "somefile.log",
        "message" : "some logs..."
    }
    "isOldestEventReached" : "false"
}
```
##### Событие `pause_live_update`
При скроллинге логов вверх подгрузка новых логов должна временно приостановиться. Для этого клиент должен сгенерировать событие `pause_live_update`. При этом на сервере в соответствующем сокете флаг `isPaused` устанавливается в *true*.

##### Событие `resume_live_update`
Генерируется на клиентской стороне. Сервер реагирует установкой флага `isPaused` обратно в *false*. При этом происходит обращение к базе за последними `logsPortion` записями, аналогично событию `sendUserData`. Отправка данных клиенту по событию `sendLogs`.



